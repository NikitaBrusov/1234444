# Асинхронное взаимодействие

{% hint style="info" %}
**Асинхронное взаимодействие** — это способ организации взаимодействия между компонентами программной системы, при котором отправитель не блокируется и может продолжать выполнение других задач, в то время как операция выполняется или ожидает ответа от получателя. В асинхронной модели отправитель и получатель не ожидают непосредственного завершения операции, а вместо этого используют механизмы обратного вызова или уведомлений для обработки результатов операции, когда они станут доступны.
{% endhint %}

<figure><img src="../.gitbook/assets/Sync (1).jpg" alt="" width="563"><figcaption><p>Асинхронное взаимодействие</p></figcaption></figure>

## Брокеры сообщений

**Message broker** (брокер сообщений) — это промежуточное программное обеспечение, которое обеспечивает асинхронную коммуникацию между различными компонентами системы, позволяя им обмениваться сообщениями. Он служит посредником между отправителем (producer) и получателем (consumer) сообщений, обеспечивая надежную доставку сообщений даже в условиях различных технологических и временных ограничений.

Основные компоненты и функции, которые предоставляет message broker:

1. **Очередь сообщений:** Брокер сообщений обеспечивает создание и управление очередью сообщений, где отправители помещают сообщения для последующей обработки или доставки получателям. Очередь гарантирует, что сообщения обрабатываются в порядке их поступления.
2. **Маршрутизация сообщений:** Брокер сообщений может выполнять функцию маршрутизации, определяя, какие сообщения должны быть доставлены конкретным получателям или группам получателей. Это позволяет гибко настраивать и управлять потоком сообщений.
3. **Гарантия доставки:** Брокер сообщений обеспечивает надежную доставку сообщений получателям. Он может использовать различные механизмы, такие как подтверждения, переотправка и повторная обработка сообщений, чтобы убедиться, что сообщение будет доставлено, даже если получатель временно недоступен или система перегружена.
4. **Преобразование сообщений:** Брокер сообщений может выполнять преобразование сообщений между различными форматами данных или протоколами, позволяя отправителям и получателям использовать разные форматы или интерфейсы.
5. **Управление подписками:** Брокер сообщений позволяет компонентам системы подписываться на определенные типы сообщений или каналы коммуникации. Это позволяет гибко настраивать поток сообщений и контролировать, какие компоненты получают какие сообщения.

Для чего используются брокеры?

* Отказоустойчивость. Даже если получатель недоуступен, то продюсер всё равно сможет опубликовать сообщение (но в топик)
* За счёт асинхронной работы можно увеличивать производительность

<figure><img src="../.gitbook/assets/Sync (2).jpg" alt=""><figcaption><p>Схема работы брокера сообщений</p></figcaption></figure>

## Kafka

Apache Kafka программный Pub-Sub брокер с открытым исходным кодом. Помимо гарантий доставки At most once и At least once, поддерживает Exactly once (Строго один раз). Обычно используется в больших проектах, так как обладает большой пропускной способностью и отказоустойчивостью, превосходит по данным характеристикам RabbitMQ и многие другие брокеры. При этом имеет высокий порог вхождения, требователен к ресурсам.

Kafka можно представить, как распределённый, реплицируемый лог коммитов. Распределённый, так как он разворачивается в виде кластера нод (под управлением Apache Zookeeper). Реплицируемый, потому что все данные синхронизируются между нодами. Лог, входящие сообщения последовательно добавляются в журнал и остаются там неизменными, не удаляются при чтении, как это происходит в RabbitMQ.

В Kafka отсутствует понятие очереди (Queue), приложения пишут или читают сообщения из партиционированных топиков (Topic). Если просто, то принцип работы такой: приложение-продюсер (Producer) отправляет сообщение в топик брокера, которое записывается в конец одной из его партиций (Partition). По умолчанию для распределения сообщений между партициями топика используется алгоритм Round-Robin. Отправитель может влиять на выбор партиции, передавая вместе с сообщением специальный ключ (Message Key).

Приложения-подписчики (Consumer) читают, вытягивают (pull) сообщения из заданного топика. Для каждого подписчика Kafka запоминает указатель на последнее прочитанное им сообщение (offset). Если приложение падает, то восстановившись может продолжать чтение с прежнего места или перемотать (rewind) offset в прошлое и прочитать данные повторно.

Для Kafka принцип «Тупой брокер, умный потребитель» означает, что, в отличие от RabbitMQ, он не занимается контролем и распределением сообщений. Потребители сами опрашивают брокер и решают, какие сообщения им читать, брокер только хранит данные.

## RabbitMQ

RabbitMQ традиционный брокер сообщений с открытым исходным кодом, работающий как автономно, так и в составе кластера. Поддерживает обе модели Pub-Sub и Point-to-Point, протоколы AMQP, MQTT, STOMP и другие. Реализованы гарантии доставки сообщений At most once и At least once.

В случае At most once получается большая пропускная способность, так как данные обрабатываются в быстрой оперативной памяти. At least once надёжный в плане доставки, но менее скоростной в плане передачи данных вариант, потому что используется механизм подтверждений и запись на диск.

В упрощённом виде принципы работы RabbitMQ можно представить так: приложение-отправитель (Publisher) публикует сообщения в брокер, ссылаясь на его внутреннюю сущность Exchange (Обменник). Обменник в зависимости от типа и настроек перенаправляет сообщения в одну или более связанных с ним очередей (Queue). Приложения-подписчики (Consumer) держат постоянное TCP соединение с RabbitMQ и ждут сообщения из заданной очереди. Брокер отправляет (push), распределяет сообщения между подписчиками. Если у очереди несколько подписчиков, сообщения между ними распределяются равномерно. Если сообщение успешно обработано подписчиком, оно удаляется из очереди.

RabbitMQ может слать подтверждение отправителю после того, как сохранил его сообщение. Или ждать подтверждения от получателя об успешной обработке взятого из очереди сообщения.

Принцип «Умный брокер, тупой потребитель» по отношению к RabbitMQ означает, что брокер берёт на себя много дополнительных действий. Например, следит за прочитанными сообщениями и удаляет их из очереди. Или сам организует процесс распределения сообщений между подписчиками.

### Выбирая между Kafka и RabbitMQ

На самом деле, категорично сравнивать брокеры сообщений очень сложно. У всех существуют свои задачи и области применения. В случае с Apache Kafka и RabbitMQ это немного разный уровень, где лучшего не существует.

Kafka используется для обработки больших объёмов данных, сотен тысяч сообщений в секунду, которые подолгу хранятся на диске и много раз читаются сотнями или даже тысячами подписчиков. Kafka — это легко масштабируемая система, обладающая повышенной отказоустойчивостью, что очень важно в крупных проектах.

RabbitMQ более простой в установке и настройке, успешно справляется с асинхронным обменом данными в микросервисной архитектуре. Не требует дополнительных компонентов и затрат на дисковые ресурсы, так как все сообщения после чтения из очереди удаляются. По сравнению с Kafka обладает большими возможностями по настройке шаблонов обмена сообщениями. Отличный выбор, если нет завышенных требований к отказоустойчивости и пропускной способности.



|   | RabbitMQ | Kafka |
| - | -------- | ----- |
|   |          |       |
|   |          |       |
|   |          |       |



Источники:&#x20;

* [https://testengineer.ru/message-broker/](https://testengineer.ru/message-broker/)
* [https://habr.com/ru/companies/innotech/articles/698838/](https://habr.com/ru/companies/innotech/articles/698838/)
